# 🔺 LeetCode 15 - 3Sum | 三數之和

---

## 📘 題目說明 | Problem Description

- **中文：**  
  給定整數陣列 `nums`，找出所有 **和為 0 的三元組**（`i ≠ j ≠ k`），不可重複。

- **English：**  
  Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i ≠ j ≠ k` and `nums[i] + nums[j] + nums[k] == 0`.

---

## 🧠 解題思路 | Approach

### 中文思路：

1. 對陣列排序。
2. 用三層邏輯：外層固定一個數 `i`，內層雙指標找剩下兩數。
3. 三數和為 0 時加入結果，並跳過重複。
4. 若 `nums[i] > 0` 提前停止；若 `nums[i] == nums[i - 1]` 則跳過避免重複。

### English:

1. Sort the array.
2. Fix one number `nums[i]`, and use two pointers to find two other numbers.
3. Skip duplicates and break early if the current number > 0.
4. Store unique triplets whose sum is 0.

---

## 💻 程式碼 | Python Code

```python
from typing import List

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        result = []
        n = len(nums)

        for i in range(n - 2):
            if nums[i] > 0:
                break
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            l, r = i + 1, n - 1
            while l < r:
                total = nums[i] + nums[l] + nums[r]
                if total < 0:
                    l += 1
                elif total > 0:
                    r -= 1
                else:
                    result.append([nums[i], nums[l], nums[r]])
                    l += 1
                    r -= 1
                    while l < r and nums[l] == nums[l - 1]:
                        l += 1
                    while l < r and nums[r] == nums[r + 1]:
                        r -= 1
        return result
```
```python
nums.sort()
```
先對 nums 進行排序。這是關鍵步驟，因為排序後才能使用雙指標技巧（two pointers），並且方便跳過重複的數字。
```python
result = []
n = len(nums)
```
- result 是最終要回傳的三元組列表。

- n 是陣列長度。
```python
for i in range(n - 2):
```
使用 for 迴圈遍歷每個數字作為三元組的第一個數，只需要跑到 n - 2，因為還需要保留兩個數字給 l 和 r。
```python
if nums[i] > 0:
    break
```
剪枝優化：

- 若目前數字 nums[i] > 0，因為陣列已排序，後面數字也都大於 0，不可能湊出 0，提早結束。
```python
if i > 0 and nums[i] == nums[i - 1]:
    continue
```
避免重複：

- 若當前的 nums[i] 和上一個相同，就跳過，避免產生重複的三元組。
```python
l, r = i + 1, n - 1
```
使用雙指標：

- l 是左指標（從 i + 1 開始）

- r 是右指標（從尾端開始）
```python
while 1 < r:
    total = nums[i] + nums[1] + nums[r]
```
進入內層迴圈，只要 l < r 就繼續檢查三數之和 total。
```python
if total < 0:
    l += 1
```
若總和小於 0，說明 l 指向的數太小，需要右移（增加總和）。
```python
elif total > 0:
    r -= 1
```
若總和大於 0，說明 r 指向的數太大，需要左移（減少總和）。
```python
else:
    result.append([nums[i], nums[i], nums[r]])
```
若總和為 0，代表找到一組合法的三元組，加入結果。
```python
l += 1
r -= 1
```
找到解後，繼續移動雙指標，尋找其他可能的三元組。
```python
while l < r and nums[l] == nums[l - 1]:
    l += 1
while l < r and nums[r] == num[r + 1]:
    r -= 1
```
跳過重複：

- 若 l 或 r 指向與前一個數相同，就持續跳過，避免重複答案。
```python
return result
```
回傳所有合法的不重複三元組。
### ✅ 總結
| 元件               | 作用            |
| ---------------- | ------------- |
| `sort()`         | 為了方便去重與雙指標操作  |
| `if nums[i] > 0` | 提前停止條件（因為已排序） |
| `l` & `r`        | 雙指標技術找三元組     |
| `跳過重複`           | 避免出現一樣的解      |

---

## 🧪 範例輸入
```python
nums = [-1, 0, 1, 2, -1, -4]
```
### 🔃 步驟一：排序
```python
nums.sort() → [-4, -1, -1, 0, 1, 2]
```
### 🔍 步驟二：固定 i 並使用雙指標 l、r 搜尋
✅ i = 0, nums[i] = -4

- l = 1 (-1), r = 5 (2)

- total = -4 + (-1) + 2 = -3 < 0 → l += 1

- l = 2 (-1), r = 5 → total = -3 → l += 1

- l = 3 (0), r = 5 → total = -2 → l += 1

- l = 4 (1), r = 5 → total = -1 → l += 1

- l = 5 → stop

👉 沒找到解

### ✅ i = 1, nums[i] = -1

- l = 2 (-1), r = 5 (2)

- total = -1 + (-1) + 2 = 0 → ✅ 找到 [-1, -1, 2]

- 跳過重複 → l += 1, r -= 1 → l = 3, r = 4

- l = 3 (0), r = 4 (1)

- total = -1 + 0 + 1 = 0 → ✅ 找到 [-1, 0, 1]

- 移動雙指標 → l = 4, r = 3 → 停止
### ⚠️ i = 2, nums[i] = -1（重複）→ 跳過

### ✅ i = 3, nums[i] = 0

- l = 4 (1), r = 5 (2)

- total = 0 + 1 + 2 = 3 → 太大 → r -= 1 → r = 4

- l = r → 停止

### 🛑 i = 4, nums[i] = 1 → 已大於 0 → 提前停止迴圈

### ✅ 最終結果
```python
[[-1, -1, 2], [-1, 0, 1]]
```

---

## ⏱ 複雜度分析 | Complexity
| 項目 | 複雜度              |
| -- | ---------------- |
| 時間 | O(n²)            |
| 空間 | O(1)   （若不算輸出結果） |

---

## 📚 我學到了什麼 | What I Learned
### 中文：

- 排序後雙指標是經典技巧。

- 控制重複的判斷要謹慎。

- 當首元素大於 0 時即可提早結束。

### English:

- Sorting helps deduplicate and optimize the search.

- Two-pointer within a for-loop is a powerful combo.

- Skipping duplicates is essential for correctness.