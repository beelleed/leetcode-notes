# 014. Longest Common Prefix æœ€é•·å…±åŒå‰ç¶´
[LeetCode é¡Œç›®é€£çµ](https://leetcode.com/problems/longest-common-prefix/)

## ğŸ§© é¡Œç›®æè¿° Description

**ä¸­æ–‡**
çµ¦å®šä¸€çµ„å­—ä¸²é™£åˆ— strsï¼Œæ‰¾å‡ºå…¶ä¸­æ‰€æœ‰å­—ä¸²çš„æœ€é•·å…±åŒå‰ç¶´ã€‚å¦‚æœä¸å­˜åœ¨å…±åŒå‰ç¶´ï¼Œå›å‚³ç©ºå­—ä¸² ""ã€‚

**English**
Given an array of strings strs, return the longest common prefix among them. If no common prefix exists, return an empty string.

---

## âœ… è§£æ³•ä¸€ï¼šä»¥ç¬¬ä¸€å€‹å­—ä¸²ç‚ºåŸºæº–

### ğŸ’¡ è§£é¡Œæƒ³æ³• Idea

**ä¸­æ–‡**
å‡è¨­ç¬¬ä¸€å€‹å­—ä¸²ç‚ºå…±åŒå‰ç¶´çš„é–‹å§‹é»ï¼Œé€å­—å…ƒæ¯”å°æ¯å€‹å­—å…ƒä½ç½®æ˜¯å¦èˆ‡æ‰€æœ‰å…¶ä»–å­—ä¸²ä¸€è‡´ã€‚è‹¥æœ‰ä¸ä¸€è‡´ï¼Œç«‹å³å›å‚³å·²ç´¯ç©çš„å‰ç¶´ã€‚

**English**
Assume the first string is the starting point of the common prefix. Compare each character position against every other string; if a mismatch occurs, return the prefix built so far.
```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""

        prefix = ""
        for i in range(len(strs[0])):  # é€ä½ç½®æ¯”å°
            char = strs[0][i]
            for word in strs:
                if i >= len(word) or word[i] != char:
                    return prefix  # ä¸€é‡åˆ°ä¸ä¸€æ¨£å°±çµæŸ
            prefix += char  # å¦‚æœéƒ½ä¸€æ¨£ï¼ŒåŠ å…¥ prefix
        return prefix
```

## ğŸ” è§£é¡Œæ­¥é©Ÿèªªæ˜
- è‹¥ strs ç‚ºç©ºï¼Œç›´æ¥å›å‚³ ""ã€‚

- ä½¿ç”¨ç¬¬ä¸€å€‹å­—ä¸²çš„é•·åº¦ä½œç‚ºã€Œæœ€å¤§å¯èƒ½å‰ç¶´é•·åº¦ã€ã€‚

- å°æ¯ä¸€å€‹å­—å…ƒä½ç½® iï¼š

    - å–å‡º ch = strs[0][i]ï¼Œä½œç‚ºåŸºæº–å­—å…ƒã€‚

    - éæ­·æ‰€æœ‰ word in strsï¼š

        - è‹¥æŸå­—ä¸²é•·åº¦ä¸è¶³ã€æˆ– word[i] ä¸ç­‰æ–¼ chï¼Œå°±å›å‚³ç›®å‰å‰ç¶´ã€‚

- è‹¥ç¬¬ä¸€å€‹å­—ä¸²ä¸€æ•´ä¸²éƒ½æ¯”å°å®Œï¼Œä»£è¡¨æ‰€æœ‰å­—ä¸²ç›¸åŒï¼Œå›å‚³æ•´ä¸²ã€‚

## ğŸ§¾ ç¤ºæ„åœ–è§£ï¼ˆä»¥ ["flower", "flow", "flight"] ç‚ºä¾‹ï¼‰ï¼š
| index | word1 | word2 | word3 | çµè«–          |
| ----- | ----- | ----- | ----- | ----------- |
| 0     | f     | f     | f     | åŠ å…¥          |
| 1     | l     | l     | l     | åŠ å…¥          |
| 2     | o     | o     | i     | çµæŸï¼Œå› ç‚º i â‰  o |
æœ€çµ‚ç­”æ¡ˆç‚º "fl"

## âœ… æ³¨æ„å„ªç¼ºé»
- å„ªé»ï¼šé‚è¼¯ç›´è§€ï¼Œæ˜“æ–¼ç†è§£ã€‚

- ç¼ºé»ï¼šéœ€è¦é¡å¤–æª¢æŸ¥ i >= len(word)ï¼Œé¿å…è¶Šç•Œï¼›æ•ˆèƒ½é›– OKï¼Œä½†ç•¥ä¸å„ªé›…ã€‚

## â±ï¸ è¤‡é›œåº¦ Complexity
- æ™‚é–“ Time: æœ€å¤šæ¯”è¼ƒ n * m æ¬¡ï¼Œn æ˜¯å­—ä¸²æ•¸ï¼Œm æ˜¯ç¬¬ä¸€å€‹å­—ä¸²é•·åº¦ â†’ O(n * m)

- ç©ºé–“ Space: é™¤äº† prefix å„²å­˜ä½¿ç”¨å¸¸æ•¸å¤–ï¼Œç„¡é¡å¤–ç©ºé–“ â†’ O(1)

---

## âœ… è§£æ³•äºŒï¼šä»¥æœ€çŸ­å­—ä¸²ç‚ºåŸºæº–

### ğŸ’¡ è§£é¡Œæƒ³æ³• Idea

**ä¸­æ–‡**
å› ç‚ºå…±åŒå‰ç¶´ä¸æœƒè¶…éæœ€çŸ­å­—ä¸²é•·åº¦ï¼Œæ‰€ä»¥å…ˆæ‰¾æœ€çŸ­å­—ä¸²ä½œç‚ºåŸºæº–ã€‚ä¾ä½ç½®æ¯”å°æ‰€æœ‰å­—ä¸²çš„å­—å…ƒï¼Œç¬¬ä¸€å€‹ä¸åŒ¹é…çš„ä½ç½®å³ç‚ºå‰ç¶´çµæŸé»ã€‚

**English**
The common prefix can't exceed the length of the shortest string. So we find the shortest string first, then compare each position across all strings. The first mismatch determines the end of the prefix.
```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        # æ‰¾å‡ºæœ€çŸ­å­—ä¸²ï¼Œå› ç‚ºå‰ç¶´ä¸å¯èƒ½é•·éæœ€çŸ­å­—ä¸²
        shortest = min(strs, key=len)
        
        # é€å­—ç¬¦æ¯”å°
        for i, ch in enumerate(shortest):
            for other in strs:
                if other[i] != ch:
                    # ä¸€æ—¦ç™¼ç¾ä¸åŒï¼Œå›å‚³ç›®å‰ i æ‰€æ§‹æˆçš„å­ä¸²
                    return shortest[:i]
        # å…¨éƒ¨ç›¸åŒå°±è¿”å›æœ€çŸ­æ•´ä¸²
        return shortest
```

## ğŸ” è§£é¡Œæ­¥é©Ÿèªªæ˜

- è‹¥ strs ç‚ºç©ºï¼Œå›å‚³ ""ã€‚

- ä½¿ç”¨ shortest = min(strs, key=len) å–å¾—æœ€çŸ­å­—ä¸²ä½œç‚ºé•·åº¦ä¸Šé™ã€‚

- é€å­—ç¬¦æ¯”å°

    - å¤–è¿´åœˆï¼šfor i, ch in enumerate(shortest)ï¼Œä»£è¡¨ä½ç½® 0ã€1ã€2...

    - å…§è¿´åœˆï¼šéæ­· strs ä¸­å…¶ä»–æ¯æ¢å­—ä¸²

    - è‹¥ä¸ç­‰æ–¼ ch â†’ å›å‚³ shortest[:i]ï¼Œå³ç•¶å‰æ¯”å°æˆç¸¾ã€‚

    - è‹¥æ•´å€‹ shortest éƒ½æ¯”å°éï¼Œä»£è¡¨å…±åŒå‰ç¶´å³ç‚º shortestï¼Œç›´æ¥å›å‚³ã€‚

## âœ… å„ªå‹¢æ¯”è¼ƒ
- è‡ªç„¶é¿é–‹è¶Šç•Œå•é¡Œï¼šä¸ç”¨å†åšé•·åº¦æª¢æŸ¥ã€‚

- ç¨‹å¼ç°¡æ½”ã€é–±è®€æ€§é«˜ï¼šé‚è¼¯æ˜“æ‡‚ä¸” Pythonicã€‚

- æ•ˆèƒ½æ›´ç©©å¥ï¼šä¸åšä¸å¿…è¦çš„æª¢æŸ¥ã€‚

## â±ï¸ è¤‡é›œåº¦ Complexity
- æ™‚é–“ Time: æœ€å¤šæ¯”è¼ƒ n * m æ¬¡ï¼Œn æ˜¯å­—ä¸²æ•¸ï¼Œm æ˜¯æœ€çŸ­å­—ä¸²é•·åº¦ â†’ O(n * m)

- ç©ºé–“ Space: å¸¸æ•¸ç©ºé–“ä½¿ç”¨ â†’ O(1)

## ğŸ” æ–¹æ³•æ¯”è¼ƒ Summary
| é …ç›®       | æ–¹æ³•ä¸€ï¼šä»¥ç¬¬ä¸€å€‹å­—ä¸²ç‚ºåŸºæº–           | æ–¹æ³•äºŒï¼šä»¥æœ€çŸ­å­—ä¸²ç‚ºåŸºæº–  |
| -------- | ----------------------- | ------------- |
| å¤§å‰æåŸå‰‡    | æ ¹æ“šç¬¬ä¸€å€‹å­—ä¸²åšæ¯”å°              | æ ¹æ“šæ‰€æœ‰å­—ä¸²ä¸­æœ€çŸ­è€…æ¯”å°  |
| æ˜¯å¦éœ€è¦è¶Šç•Œåˆ¤æ–· | âœ… æ˜¯ï¼ˆéœ€ `i >= len(word)`ï¼‰ | âŒ ä¸éœ€è¦         |
| èªæ„æ¸…æ™°åº¦    | âœ… ç›´è¦ºç†è§£å¥½                 | âœ… æ›´å®‰å…¨ä¸”æ›´ç¬¦åˆç¾å¯¦å‰æ |
| ç¨‹å¼ç¢¼ç°¡æ½”åº¦   | ä¸­ç­‰                      | âœ… ç°¡æ½”ä¸”ä¹¾æ·¨       |

## âœ… å­¸åˆ°ä»€éº¼ï¼ˆTakeawaysï¼‰
å…±åŒå‰ç¶´ä¸å¯è¶…éæœ€çŸ­å­—ä¸²ï¼šé€™æ˜¯æœ€ç©©å®šçš„å‰æã€‚

é€å­—æ¯”è¼ƒ + ç•¶ä¸‹å³å›å‚³ï¼šç•¶ä½ é‡åˆ°ç¬¬ä¸€å€‹ mismatchï¼Œå°±ä¸ç”¨å†ç´¯ç©ã€‚

ç¨‹å¼è¨­è¨ˆå“²å­¸ï¼šé¿å…å¾Œè¨­æª¢æŸ¥ï¼ˆå¦‚ i >= len(word)ï¼‰ï¼Œè®“ç¨‹å¼ç¢¼æ›´å–®ç´”ã€æ›´ç©©å¥ã€‚

æ¡ç”¨ Pythonic æ–¹æ³•ï¼šmin(strs, key=len)ã€enumerate æ˜¯å¼·åŒ–é‚è¼¯çš„å¥½å·¥å…·ã€‚