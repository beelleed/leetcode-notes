# 🔐 LeetCode 91 — Decode Ways / 解碼方法
🔗 [題目連結](https://leetcode.com/problems/decode-ways/)

---

## 📄 題目說明 | Problem Description

- **中文**：給定一個只包含數字的非空字串 `s`，解碼規則是：  
  `'1'` → `A`、`'2'` → `B`、…、`'26'` → `Z`。  
  求這個字串有多少種不同的解碼方式。若該字串無法完整解碼則回傳 0。

- **English**: Given a non-empty string `s` containing only digits, determine the total number of ways to decode it using the mapping:
    `'1'` → `A`、`'2'` → `B`、…、`'26'` → `Z`。 
    If a string cannot be fully decoded, return 0.

### ⚠️ 要注意的規則
- 字符 `'0'` 本身 **無法單獨解碼**（沒有編碼對應 `'0'`）。  
- 兩位數解碼必須在 `10` 到 `26` 範圍內，且不能有前導零。  
- 如果整個字串無法合法解碼，就回傳 0。

### Examples
- Example 1:

    - Input: s = "12"

    - Output: 2

    - Explanation: "12" could be decoded as "AB" (1 2) or "L" (12).

- Example 2:

    - Input: s = "226"

    - Output: 3

    - Explanation: "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).

- Example 3:

    - Input: s = "06"

    - Output: 0

    - Explanation: "06" cannot be mapped to "F" because of the leading zero ("6" is different from "06"). In this case, the string is not a valid encoding, so return 0.

---

## 🧠 解題思路 | Solution Idea

這題可以拆為動態規劃 (DP) 類型：

我們定義一個陣列 `dp`，其中 `dp[i]` 表示：將前 i 個字元（即 `s[:i]`）解碼的方法數量。

轉移邏輯：

1. **單個字元解碼**：如果 `s[i-1] != '0'`，那麼這個字元可以作為一個獨立解碼 → `dp[i] += dp[i-1]`  
2. **兩個字元合併解碼**：如果前一位與這一位構成的數字在 10 到 26 之間（且前一位不是 '0'）→ `dp[i] += dp[i-2]`

邊界條件：
- `dp[0] = 1`：空字串有 1 種解碼方式（什麼都不做）  
- `dp[1] = 1`（只要 `s[0] != '0'`）：第一個字元如果不是 `'0'` 就有 1 種方式

整體方向就是從左到右，一步步累加可能的解碼方式。

---

## 💻 程式碼實作 | Code (Python)

```python
from typing import List

class Solution:
  def numDecodings(self, s: str) -> int:
      # 若字串空或開頭是 '0'，無法解碼
      if not s or s[0] == '0':
          return 0

      n = len(s)
      # dp[i] 表示前 i 個字元有多少種解碼方式
      dp = [0] * (n + 1)
      dp[0] = 1
      dp[1] = 1  # 前提是 s[0] != '0'

      for i in range(2, n + 1):
          # 單個字元部分：s[i-1]
          if s[i - 1] != '0':
              dp[i] += dp[i - 1]

          # 兩位數部分：s[i-2:i]
          two = int(s[i - 2 : i])
          if 10 <= two <= 26:
              dp[i] += dp[i - 2]

      return dp[n]
```

| 區段    | 程式碼                                                                     | 功能 / 解釋                         |
| ----- | ----------------------------------------------------------------------- | ------------------------------- |
| 邊界檢查  | `if not s or s[0] == '0': return 0`                                     | 如果字串空或開頭為 `'0'`，直接回傳 0          |
| 初始化   | `n = len(s)`<br>`dp = [0] * (n + 1)`<br>`dp[0] = 1`、`dp[1] = 1`         | 建立 dp 陣列與基底值                    |
| 主迴圈   | `for i in range(2, n + 1):`                                             | 從 i = 2 開始逐步計算 dp[i]            |
| 單字元解碼 | `if s[i - 1] != '0': dp[i] += dp[i - 1]`                                | 若最後一個數字不是 '0'，它可以單獨解碼           |
| 兩字元解碼 | `two = int(s[i - 2 : i])` <br> `if 10 <= two <= 26: dp[i] += dp[i - 2]` | 若前兩位可以整合為一個合法數字（10–26），加入對應方式數量 |
| 返回結果  | `return dp[n]`                                                          | 前 n 個字元（整個字串）的解碼方式數量            |

### ✅ dp[0] = 1

- 這是「空字串」的解碼方法數，定義為 1 種。

    👉 為什麼不是 0？因為「不解碼」也是一種狀況。我們設 dp[0] = 1 代表「什麼都不選」的起點。

### ✅ dp[1] = 1

- 這是第一個字元（s[0]）的情況：

    - 如果 s[0] != '0'，代表它可以被解成一個字母（例如 '2' → 'B'），就有 1 種方法。

    - 如果 s[0] == '0'，整體就會提前 return 0，因為 '0' 不能單獨解碼。

### ✅ dp[i] += dp[i - 1]
- 這表示：如果第 i 個字元（也就是 s[i - 1]）不是 '0'，那它可以自己單獨解碼成一個字母。
所以我們就可以從 dp[i - 1] 的基礎上，加上這一種方式。

- 📌 舉例：
    - s = "123"，我們處理到 i = 3（表示字串 "123"）

    - s[2] = '3' 不是 0 → 它可以自己當 'C'

    - 所以 dp[3] += dp[2]：代表我們在 "12" 的所有解法後面加上一個 'C'，就多出這些方法

### ✅ s[i - 2 : i] 是什麼？

- 這是取長度為 2 的子字串（包括 s[i - 2] 和 s[i - 1]）

    👉 例如 s = "226"，當 i = 3 時，s[i - 2 : i] = s[1:3] = "26"

- 這兩位數如果是 10～26，就代表它們可以被視為一個字母（例如 '26' → 'Z'）

### ✅ dp[i] += dp[i - 2]

- 如果 s[i - 2 : i] 是有效的兩位數（10~26），我們就可以把它當作一個字母來看。

- 這樣的話，dp[i - 2] 就是去掉這兩個字母前面那段的解法總數
→ 再把「這兩個合成一個字母」接在每個解法後面。

- 📌 舉例：
    - s = "226"，i = 3

    - s[1:3] = "26" 合法

    - 所以 dp[3] += dp[1] = 1

    因為「2（A）」後面加上 "26" → Z，這是一種解法：「A Z」

---

## 🧪 範例 1：s = "12"

```python
s = "12"
n = 2
dp = [1, 1, 0]
```

### 迴圈從 i = 2 開始：
- i = 2：

    - dp = [1, 1, 0] → 開始時 dp[2] = 0

    - s[1] = '2' ✅ → dp[2] += dp[1] = 1

    - s[0:2] = '12' ✅ → dp[2] += dp[0] = 1
        → dp = [1, 1, 2]

- ✔️ 最後回傳 dp[2] = 2

## 🧪 範例 2：s = "226"
```python
s = "226"
n = 3
dp = [1, 1, 0, 0]  # 初始化
```
- i = 2：

    - s[1] = '2' ✅ → dp[2] += dp[1] = 1

    - s[0:2] = '22' ✅ → dp[2] += dp[0] = 1
        → dp = [1, 1, 2, 0]

- i = 3：

    - s[2] = '6' ✅ → dp[3] += dp[2] = 2

    - s[1:3] = '26' ✅ → dp[3] += dp[1] = 1
        → dp = [1, 1, 2, 3]

- ✔️ 最後回傳 dp[3] = 3

## 🧪 範例 3：s = "06
```python
s = "06"
n = 2
```
- dp = [1, 1, 0] → 錯誤！`s[0] = '0'` → `dp[1] = 0`
    → 修正：`dp = [1, 0, 0]`

-  i = 2：
    - `s[1] = '6'` ✅ → `dp[2] += dp[1] = 0`
    
    - `s[0:2] = '06'` ❌ invalid
        → `dp = [1, 0, 0]`

- ✔️ 最後回傳 `dp[2] = 0`

---

## ⏱ 複雜度分析 | Complexity

- 時間複雜度：O(n)，我們只對字串做一遍迴圈

- 空間複雜度：O(n)，使用 dp 陣列大小為 n+1 可以進一步空間優化到 O(1)，只用兩個變數保存前兩個 dp 狀態。

## ✍️ 我學到的東西 | What I Learned

- DP 狀態設計技巧：很多子問題可用前面結果累加。

- 處理零的特殊情況：'0' 本身無解碼作用，但可能與前面合併解碼。

- 子問題重疊：重用 dp[i-1]、dp[i-2] 避免重複計算。

- 先檢查邊界與異常情況：像開頭是 '0'、字串空不能直接忽略。