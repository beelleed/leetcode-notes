# ğŸ  LeetCode 213 â€” House Robber II / æ‰“å®¶åŠ«èˆ II
ğŸ”— [é¡Œç›®é€£çµ](https://leetcode.com/problems/house-robber-ii/)

---

## ğŸ“„ é¡Œç›®èªªæ˜ | Problem Description

- **ä¸­æ–‡**ï¼šæœ‰ä¸€æ’å±‹å­æ’æˆä¸€å€‹åœ“åœˆï¼Œæ¯å€‹å±‹å­è£¡æœ‰ä¸€å®šæ•¸é‡çš„é‡‘éŒ¢ï¼ˆ`nums[i]`ï¼‰ã€‚å¦‚æœä½ å·ç›¸é„°çš„å…©å€‹æˆ¿å­å°±æœƒè§¸å‹•è­¦å ±ã€‚å› ç‚ºæ˜¯åœ“å½¢æ’åˆ—ï¼Œç¬¬ä¸€å€‹å’Œæœ€å¾Œä¸€å€‹æˆ¿å­äº’ç‚ºé„°å±…ã€‚æ±‚åœ¨ä¸è§¸è­¦å ±çš„æƒ…æ³ä¸‹ï¼Œèƒ½å·åˆ°çš„æœ€å¤§é‡‘é¡ã€‚

- **English**: Houses are arranged in a circle, each house has some money. You cannot rob two adjacent houses or else the alarm triggers. Because it's a circle, the first and last house are adjacent. Return the maximum money you can rob without alerting the police.

- **Examples**
    - Example 1:

        - Input: nums = [2,3,2]
        - Output: 3
        - Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.

    - Example 2:

        - Input: nums = [1,2,3,1]
        - Output: 4
        - Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.

    - Example 3:

        - Input: nums = [1,2,3]
        - Output: 3

---

## ğŸ§  è§£é¡Œæ€è·¯ | Solution Idea

### æ–¹æ³•ä¸€

é€™é¡Œæ˜¯ â€œHouse Robber Iï¼ˆ198 é¡Œï¼‰â€ çš„å»¶ä¼¸ç‰ˆæœ¬ï¼Œå·®ç•°åœ¨æ–¼åœ“åœˆçš„çµæ§‹ä½¿å¾—ç¬¬ä¸€å®¶å’Œæœ€å¾Œä¸€å®¶ä¸èƒ½åŒæ™‚è¢«å·ã€‚æ ¸å¿ƒæƒ³æ³•æ˜¯ï¼š

1. **æ‹†æˆå…©å€‹ç·šæ€§å•é¡Œ (linear cases)**  
   - ä¸å·ç¬¬ 1 å€‹æˆ¿å­ï¼šè€ƒæ…®å€é–“ `nums[1:]`  
   - ä¸å·æœ€å¾Œä¸€å€‹æˆ¿å­ï¼šè€ƒæ…®å€é–“ `nums[:-1]`  
   é€™æ¨£å°±ä¸æœƒåŒæ™‚è§¸åŠç¬¬ä¸€èˆ‡æœ€å¾Œçš„é‚Šç•Œå•é¡Œã€‚

2. æ¯å€‹ç·šæ€§å­å•é¡Œå°±å¯ä»¥ç”¨èˆ‡ House Robber I åŒæ¨£çš„ DP æ–¹æ³•æ±‚è§£ã€‚

3. æœ€å¾Œå–é€™å…©å€‹çµæœçš„æœ€å¤§å€¼ï¼Œå°±æ˜¯åŸæœ¬åœ“å½¢æ’åˆ—çš„ç­”æ¡ˆã€‚

ç”¨é€™æ¨£æ‹†è§£å¾Œï¼Œè¤‡é›œåº¦ä»æ˜¯ O(n)ï¼Œç©ºé–“å¯ä»¥å„ªåŒ–åˆ° O(1)ã€‚

### æ–¹æ³•äºŒ

- æˆ¿å­æ’æˆä¸€åœˆï¼Œå› æ­¤ç¬¬ä¸€é–“å’Œæœ€å¾Œä¸€é–“ä¸èƒ½åŒæ™‚è¢«å·ã€‚
- ä¸èƒ½å·ç›¸é„°çš„æˆ¿å­ã€‚
- æ±‚åœ¨é€™äº›é™åˆ¶ä¸‹å¯ä»¥å·åˆ°çš„æœ€å¤§é‡‘é¡ã€‚

ç‚ºäº†è§£æ±ºã€Œç’°ç‹€ã€é€™å€‹é™åˆ¶ï¼Œæˆ‘å€‘æŠŠå•é¡Œæ‹†æˆå…©å€‹ç·šæ€§ç‰ˆæœ¬ï¼š  
1. ä¸å·æœ€å¾Œä¸€é–“ â†’ å· `nums[0 .. n-2]`  
2. ä¸å·ç¬¬ä¸€é–“ â†’ å· `nums[1 .. n-1]`  
æœ€å¾Œå–å¾—å…©å€‹çµæœçš„æœ€å¤§å€¼å³ç‚ºç­”æ¡ˆã€‚  

---

## ğŸ’» ç¨‹å¼ç¢¼å¯¦ä½œ | Code (Python) - linear

```python
from typing import List

class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        if n == 1:
            return nums[0]

        # ç·šæ€§ç‰ˆæœ¬çš„ rob å‡½å¼ï¼ˆå¾ start åˆ° end åŒ…å«ï¼‰
        def rob_linear(houses: List[int]) -> int:
            prev1, prev2 = 0, 0
            # prev1 = å‰ä¸€å€‹ä½ç½®å·æˆ–ä¸å·çš„æœ€å¤§å€¼
            # prev2 = å‰å…©å€‹ä½ç½®çš„æœ€å¤§å€¼
            for x in houses:
                # æ–°çš„ prev1 æ˜¯ä¸è¦å·é€™é–“ï¼šmax(prev1, prev2 + x?) å…¶å¯¦æ˜¯ max(prev1, prev2 + x) ä½†é€™é‚Šç”¨ prev2 + x
                new_val = max(prev1, prev2 + x)
                prev2 = prev1
                prev1 = new_val
            return prev1

        # ä¸å·æœ€å¾Œä¸€æ£Ÿ â†’ rob_linear(nums[0 : n-1])
        case1 = rob_linear(nums[:-1])
        # ä¸å·ç¬¬ä¸€æ£Ÿ â†’ rob_linear(nums[1 : n])
        case2 = rob_linear(nums[1:])

        return max(case1, case2)
```
```python
n = len(nums)
if n == 0:
    return 0
if n == 1:
    return nums[0]
```
- å…ˆè™•ç†é‚Šç•Œæƒ…æ³ï¼š

    - å¦‚æœ nums æ˜¯ç©ºçš„ï¼Œæ²’æœ‰æˆ¿å­å¯å·ï¼Œå›å‚³ 0ã€‚

    - å¦‚æœåªæœ‰ä¸€å€‹æˆ¿å­ï¼Œç­”æ¡ˆå°±æ˜¯é€™å€‹æˆ¿å­çš„é‡‘é¡ã€‚
```python
def rob_linear(houses: List[int]) -> int:
    prev1, prev2 = 0, 0
    for x in houses:
        new_val = max(prev1, prev2 + x)
        prev2 = prev1
        prev1 = new_val
    return prev1
```
- é€™æ˜¯ ç·šæ€§ç‰ˆæœ¬çš„æ‰“å®¶åŠ«èˆï¼ˆèˆ‡ LeetCode 198 é¡Œç›¸åŒï¼‰ï¼š

    - prev1 è¡¨ç¤ºã€Œåˆ°ç›®å‰ä½ç½®ï¼ˆåŒ…æ‹¬å‰ä¸€æˆ¿å­ï¼‰èƒ½å·åˆ°çš„æœ€å¤§é‡‘é¡ã€

    - prev2 è¡¨ç¤ºã€Œåˆ°å‰å‰ä¸€å€‹ä½ç½®èƒ½å·åˆ°çš„æœ€å¤§é‡‘é¡ã€

    - ç•¶æˆ‘å€‘è€ƒæ…®å·æˆ–ä¸å·ç•¶å‰æˆ¿å­ x æ™‚ï¼Œ

        - ä¸å·çš„è©±èƒ½æ‹¿åˆ° prev1

        - å·çš„è©±å°±æ˜¯ prev2 + x

    - æ‰€ä»¥ new_val = max(prev1, prev2 + x)

    - æ›´æ–°è®Šæ•¸ï¼šæŠŠ prev1 çµ¦ prev2ï¼Œç„¶å¾Œæ–°çš„å€¼çµ¦ prev1

    - æœ€å¾Œå›å‚³ prev1ï¼ˆä»£è¡¨æ•´å€‹ç·šæ€§æ®µçš„æœ€å„ªè§£ï¼‰

```python
case1 = rob_linear(nums[:-1])
case2 = rob_linear(nums[1:])
return max(case1, case2)
```
- å› ç‚ºåŸé¡Œæ˜¯åœ“å½¢æ’åˆ—ï¼Œç¬¬ä¸€é–“èˆ‡æœ€å¾Œä¸€é–“æ˜¯é„°å±…ï¼Œä¸èƒ½åŒæ™‚å·ã€‚

- æ‰€ä»¥æ‹†æˆå…©ç¨®æƒ…æ³è¨ˆç®—ï¼š

    1. ä¸å·æœ€å¾Œä¸€é–“ â†’ nums[:-1]ï¼ˆå¾ç¬¬ 0 åˆ°å€’æ•¸ç¬¬ 2 é–“æˆ¿å­ï¼‰

    2. ä¸å·ç¬¬ä¸€é–“ â†’ nums[1:]ï¼ˆå¾ç¬¬ 1 é–“åˆ°æœ€å¾Œä¸€é–“æˆ¿å­ï¼‰

- åˆ†åˆ¥å°é€™å…©æ¢ç·šæ€§æƒ…æ³å‘¼å« rob_linearï¼Œç„¶å¾Œå–å…©è€…çš„æœ€å¤§å€¼åšç‚ºæœ€çµ‚ç­”æ¡ˆã€‚

---

## ğŸ§ª ç¯„ä¾‹
```python
nums = [2, 3, 2]
```
### é‹ç®— case1 = rob_linear(nums[:-1])

- nums[:-1] æ˜¯ [2, 3]ï¼ˆä¸å·æœ€å¾Œä¸€é–“ï¼‰

- å‘¼å« rob_linear([2, 3])

- åœ¨ rob_linear ä¸­ï¼š

    - åˆå§‹åŒ– prev1 = 0, prev2 = 0

    - ç¬¬ä¸€é–“æˆ¿å­ x = 2

        - new_val = max(prev1 (=0), prev2 + x = 0 + 2) = 2

        - æ›´æ–°ï¼šprev2 = prev1 (0), prev1 = new_val (2) â†’ ç¾åœ¨ prev1=2, prev2=0

    - ç¬¬äºŒé–“æˆ¿å­ x = 3

        - new_val = max(prev1 (=2), prev2 + x = 0 + 3) = 3

        - æ›´æ–°ï¼šprev2 = prev1 (2), prev1 = new_val (3) â†’ æœ€çµ‚ prev1 = 3

    - è¿”å› 3

- æ‰€ä»¥ case1 = 3

### é‹ç®— case2 = rob_linear(nums[1:])

- nums[1:] æ˜¯ [3, 2]ï¼ˆä¸å·ç¬¬ä¸€é–“ï¼‰

- å‘¼å« rob_linear([3, 2])

- åœ¨ rob_linear ä¸­ï¼š

    - åˆå§‹åŒ– prev1 = 0, prev2 = 0

    - x = 3

        - new_val = max(0, 0 + 3) = 3

        - æ›´æ–°ï¼šprev2 = 0, prev1 = 3

    - x = 2

        - new_val = max(prev1 = 3, prev2 + x = 0 + 2) = 3

        - æ›´æ–°ï¼šprev2 = 3, prev1 = 3

    - è¿”å› 3

- æ‰€ä»¥ case2 = 3

### æœ€çµ‚ç­”æ¡ˆ

- max(case1, case2) = max(3, 3) = 3

- æ‰€ä»¥ rob([2,3,2]) = 3

---

## â± è¤‡é›œåº¦åˆ†æ | Complexity

- æ™‚é–“è¤‡é›œåº¦ï¼šO(n) â€” æˆ‘å€‘å° nums[:-1] å’Œ nums[1:] å„æƒæä¸€é

- ç©ºé–“è¤‡é›œåº¦ï¼šO(1) â€” rob_linear ç”¨å¸¸æ•¸é¡å¤–ç©ºé–“ï¼Œé™¤äº†è¼¸å…¥åˆ‡ç‰‡ï¼ˆå¦‚æœç®—åˆ‡ç‰‡é‚£éƒ¨åˆ†çš„é¡å¤–ç©ºé–“ï¼‰

---

## ğŸ’» ç¨‹å¼ç¢¼å¯¦ä½œ | Code (Python) - DP
```python
from typing import List

class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        # é‚Šç•Œè™•ç†
        if n == 0:
            return 0
        if n == 1:
            return nums[0]

        # ç·šæ€§ç‰ˆæœ¬çš„æ‰“å®¶åŠ«èˆï¼Œç”¨å®Œæ•´ dp é™£åˆ—å¯«æ³•
        def rob_linear_dp(houses: List[int]) -> int:
            m = len(houses)
            if m == 0:
                return 0
            if m == 1:
                return houses[0]
            # dp[i] è¡¨ç¤ºå·åˆ° houses[i]ï¼ˆè€ƒæ…®åˆ°ç¬¬ i é–“ï¼‰æ™‚çš„æœ€å¤§é‡‘é¡
            dp = [0] * m
            dp[0] = houses[0]
            dp[1] = max(houses[0], houses[1])
            # å¾ç¬¬ä¸‰é–“ (index=2) é–‹å§‹
            for i in range(2, m):
                # å·é€™é–“ï¼šdp[i-2] + houses[i]
                # ä¸å·é€™é–“ï¼šdp[i-1]
                dp[i] = max(dp[i - 1], dp[i - 2] + houses[i])
            return dp[-1]


        # æƒ…æ³ä¸€ï¼šä¸å·æœ€å¾Œä¸€é–“
        case1 = rob_linear_dp(nums[:-1])
        # æƒ…æ³äºŒï¼šä¸å·ç¬¬ä¸€é–“
        case2 = rob_linear_dp(nums[1:])

        return max(case1, case2)
```
### é‚Šç•Œè™•ç†
```python
n = len(nums)
if n == 0:
    return 0
if n == 1:
    return nums[0]
```
- è‹¥ç„¡æˆ¿å­å¯å·ï¼Œå›å‚³ 0

- è‹¥åªæœ‰ä¸€é–“æˆ¿å­ï¼Œå·é‚£é–“å°±æ˜¯æœ€å¤§é‡‘é¡

### ç·šæ€§ç‰ˆ DPï¼šrob_linear_dp
```python
m = len(houses)
if m == 0:
    return 0
if m == 1:
    return houses[0]
dp = [0] * m
dp[0] = houses[0]
dp[1] = max(houses[0], houses[1])
```
- è‹¥ç·šæ€§å­åˆ—é•·åº¦ç‚º 0ã€1ï¼Œç›´æ¥è™•ç†

- åˆå§‹åŒ– dp[0] å’Œ dp[1]ï¼Œè¡¨ç¤ºå‰ 1 é–“æˆ–å‰ 2 é–“å·åˆ°çš„æœ€å¤§é‡‘é¡
```python
for i in range(2, m):
    dp[i] = max(dp[i - 1], dp[i - 2] + houses[i])
```
- å°æ–¼ç¬¬ i é–“æˆ¿å­ï¼Œæœ‰å…©ç¨®é¸æ“‡ï¼š

    - ä¸å·ç¬¬ i é–“ï¼šå¾—åˆ° dp[i - 1]

    - å·ç¬¬ i é–“ï¼šå¾—åˆ° dp[i - 2] + houses[i]

    - é¸è¼ƒå¤§çš„é‚£ä¸€å€‹

- æœ€å¾Œ return dp[-1] æŠŠæœ€å¾Œä¸€é–“æˆ¿å­çš„æœ€å¤§å·ç›œé‡‘é¡ç•¶ä½œç·šæ€§å­å•é¡Œçš„ç­”æ¡ˆã€‚

---

## ğŸ§ª ç¯„ä¾‹

- å‡è¨­ nums = [2, 7, 9, 3, 1]

### æƒ…æ³ä¸€ï¼ˆæ’é™¤æœ€å¾Œä¸€é–“ï¼‰ â†’ [2, 7, 9, 3]

- m = 4

- dp åˆå§‹åŒ–ï¼šdp = [2, max(2,7)=7, 0, 0] â†’ dp = [2, 7, 0, 0]

- i = 2 â†’ dp[2] = max(dp[1], dp[0] + 9) = max(7, 2+9=11) = 11

- i = 3 â†’ dp[3] = max(dp[2], dp[1] + 3) = max(11, 7+3=10) = 11
â†’ case1 = 11

### æƒ…æ³äºŒï¼ˆæ’é™¤ç¬¬ä¸€é–“ï¼‰ â†’ [7, 9, 3, 1]

- m = 4

- dp åˆå§‹åŒ–ï¼šdp = [7, max(7,9)=9, 0, 0] â†’ dp = [7, 9, 0, 0]

- i = 2 â†’ dp[2] = max(dp[1], dp[0] + 3) = max(9,7+3=10) = 10

- i = 3 â†’ dp[3] = max(dp[2], dp[1] + 1) = max(10,9+1=10) = 10
â†’ case2 = 10

çµæœï¼šmax(case1, case2) = max(11, 10) = 11

æ‰€ä»¥ rob([2,7,9,3,1]) = 11

---

## ğŸ“ˆ è¤‡é›œåº¦åˆ†æï¼ˆDP æ–¹æ³•ï¼‰| Complexity

### âœ… æ™‚é–“è¤‡é›œåº¦ï¼šO(n)

- rob_linear_dp() ä¸­çš„è¿´åœˆè·‘ä¸€æ¬¡é•·åº¦ç‚º n çš„é™£åˆ—ï¼ŒåŸ·è¡Œæ™‚é–“ç‚º O(n)

- åˆ†æˆå…©æ®µå€é–“ï¼ˆæ’é™¤ç¬¬ä¸€å€‹èˆ‡æ’é™¤æœ€å¾Œä¸€å€‹ï¼‰ï¼Œç¸½å…±ä»æ˜¯ O(n)

### âœ… ç©ºé–“è¤‡é›œåº¦ï¼š

- è‹¥ä½¿ç”¨ å®Œæ•´ dp é™£åˆ—å¯«æ³•ï¼šO(n)

- è‹¥ä½¿ç”¨ ç©ºé–“å„ªåŒ–ç‰ˆï¼ˆåªç”¨å…©å€‹è®Šæ•¸ï¼‰ï¼šO(1)

---

## âœï¸ æˆ‘å­¸åˆ°çš„æ±è¥¿ | What I Learned

- é‡åœ“å½¢ï¼é¦–å°¾ç›¸æ¥å•é¡Œæ™‚ï¼Œå¯ä»¥æ‹†æˆå¤šå€‹ç·šæ€§æƒ…å¢ƒä¾†è§£

- å¸¸æ•¸ç©ºé–“å„ªåŒ– DPï¼šç”¨å…©å€‹è®Šæ•¸ä»£æ›¿æ•´å€‹ dp é™£åˆ—

- å­å•é¡Œè¤‡ç”¨ï¼šå…©å€‹å­æƒ…å¢ƒå…±ç”¨åŒä¸€æ®µ DP é‚è¼¯

- ç‰¹æ®Šæƒ…æ³è™•ç†å¾ˆé‡è¦ï¼šç©ºé™£åˆ—ã€ä¸€æ£Ÿæˆ¿å­çš„æƒ…æ³è¦å…ˆè™•ç†