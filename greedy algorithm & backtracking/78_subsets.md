# ğŸŒŸ LeetCode 78 - Subsets å­é›†å•é¡Œ
ğŸ”— [é¡Œç›®é€£çµ](https://leetcode.com/problems/subsets/)

---

## ğŸ“˜ é¡Œç›®èªªæ˜ | Problem Description
### ä¸­æ–‡ï¼š
çµ¦å®šä¸€å€‹æ•´æ•¸é™£åˆ— numsï¼Œå…¶ä¸­å…ƒç´ äº’ä¸ç›¸åŒï¼Œè«‹è¿”å›è©²é™£åˆ—æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå³å†ªé›†ï¼‰ã€‚è§£é›†ä¸èƒ½åŒ…å«é‡è¤‡çš„å­é›†ï¼Œä¸”å­é›†çš„é †åºå¯ä»¥ä»»æ„ã€‚

### English:
Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.

### Examples
- Example 1:

    - Input: nums = [1,2,3]
    - Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
- Example 2:

    - Input: nums = [0]
    - Output: [[],[0]]

---

## ğŸ§  è§£é¡Œæ€è·¯ | Solution Strategy
âœ… æ ¸å¿ƒæƒ³æ³•ï¼š
- æ¯å€‹å…ƒç´ éƒ½æœ‰å…©ç¨®é¸æ“‡ï¼šåŒ…å«æˆ–ä¸åŒ…å«ã€‚

- å› æ­¤ï¼Œå°æ–¼é•·åº¦ç‚º n çš„é™£åˆ—ï¼Œç¸½å…±æœ‰ 2^n ç¨®å­é›†ã€‚

- æˆ‘å€‘å¯ä»¥é€éï¼š

    - ğŸ” å›æº¯æ³•ï¼ˆBacktrackingï¼‰ é€æ­¥å˜—è©¦æ‰€æœ‰é¸æ“‡ã€‚

    - âš™ï¸ ä½å…ƒæ“ä½œï¼ˆBit Manipulationï¼‰ ä½¿ç”¨äºŒé€²ä½è¡¨ç¤ºé¸èˆ‡ä¸é¸çš„çµ„åˆã€‚


âœ… Core Idea:
- Each element has two options: include or not include.

- Therefore, for an array of length n, there are 2^n possible subsets.

- We can generate all subsets using:

    - ğŸ” Backtracking: recursively explore inclusion/exclusion of each element.

    - âš™ï¸ Bit Manipulation: use binary representation to simulate choices (e.g., 1 for include, 0 for exclude).

---

## ğŸ’» Python ç¨‹å¼ç¢¼ | Python Code
### æ–¹æ³•ä¸€ï¼šå›æº¯æ³•ï¼ˆBacktrackingï¼‰
```python
from typing import List

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []

        def backtrack(start: int, path: List[int]):
            res.append(path[:])
            for i in range(start, len(nums)):
                path.append(nums[i])
                backtrack(i + 1, path)
                path.pop()

        backtrack(0, [])
        return res
```
#### ğŸ“˜ å®Œæ•´ç¨‹å¼ç¢¼èˆ‡è©³ç´°èªªæ˜
```python
from typing import List

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []  # ç”¨ä¾†å„²å­˜æ‰€æœ‰çš„å­é›†çµæœ

        def backtrack(start: int, path: List[int]):
            res.append(path[:])  # æ¯ä¸€æ¬¡é€²å…¥éè¿´ï¼Œå°±åŠ å…¥ç•¶å‰ path çš„å‰¯æœ¬ç‚ºä¸€å€‹å­é›†
```
- é€™è£¡çš„ path[:] æ˜¯æ·ºæ‹·è²ï¼Œè¡¨ç¤ºä¿ç•™ç›®å‰å­é›†å…§å®¹ï¼Œé¿å…å¾Œé¢éè¿´æ”¹è®Š path æ™‚å½±éŸ¿ä¹‹å‰çµæœã€‚
```python
for i in range(start, len(nums)):
    path.append(nums[i])         # é¸æ“‡é€™å€‹å…ƒç´ 
    backtrack(i + 1, path)       # å¾ä¸‹ä¸€å€‹ä½ç½®é–‹å§‹ç¹¼çºŒéè¿´
    path.pop()                   # å›æº¯ï¼šç§»é™¤æœ€å¾Œä¸€å€‹åŠ å…¥çš„å…ƒç´ ï¼Œç¹¼çºŒå˜—è©¦åˆ¥çš„çµ„åˆ

```
- ğŸ” è§£é‡‹ for è¿´åœˆï¼š
    - å¾ start é–‹å§‹éæ­·ï¼Œç¢ºä¿ç”¢ç”Ÿçš„æ˜¯ä¸é‡è¤‡ä¸”éå¢çš„å­é›†ã€‚
        - å¦‚æœä¸ç”¨ startï¼Œæœƒç™¼ç”Ÿä»€éº¼äº‹ï¼Ÿ
            - ä½ æœƒå¾é ­éæ­· numsï¼Œå°è‡´åƒ [1,2] å’Œ [2,1] éƒ½å‡ºç¾ï¼Œé€™é•åäº†ã€Œå­é›†ã€çš„å®šç¾©ï¼ˆé †åºä¸å½±éŸ¿ï¼Œä½†ä¸èƒ½é‡è¤‡æ’åˆ—çµ„åˆï¼‰ã€‚

    - æ¯å±¤é¸ä¸€å€‹å…ƒç´ åŠ å…¥ pathï¼Œç„¶å¾Œå‘ä¸‹éè¿´ã€‚

    - å›ä¾†æ™‚ç”¨ pop() ç§»é™¤å‰›å‰›åŠ å…¥çš„ï¼Œæº–å‚™è©¦åˆ¥çš„å…ƒç´ ï¼ˆå›æº¯æ ¸å¿ƒæ­¥é©Ÿï¼‰ã€‚
```python
backtrack(0, [])  # å¾ index 0 é–‹å§‹ï¼Œåˆå§‹ path ç‚ºç©ºé›†åˆ []
return res        # å›å‚³æ‰€æœ‰å­é›†
```
#### ğŸ” ä»¥ [1, 2, 3] ç‚ºä¾‹ï¼Œå›æº¯å±•é–‹æ­¥é©Ÿï¼š
```css
[]
â”œâ”€â”€ [1]
â”‚   â”œâ”€â”€ [1,2]
â”‚   â”‚   â””â”€â”€ [1,2,3]
â”‚   â””â”€â”€ [1,3]
â”œâ”€â”€ [2]
â”‚   â””â”€â”€ [2,3]
â””â”€â”€ [3]
```
ğŸ”¹ Step 1: å‘¼å« backtrack(0, [])
- res = [[]]ï¼ˆåˆå§‹ç©ºå­é›†ï¼‰

- start = 0ï¼Œi = 0

ğŸ”¹ Step 2: åŠ å…¥ 1 â†’ path = [1]ï¼Œå‘¼å« backtrack(1, [1])
- res = [[], [1]]

- start = 1ï¼Œi = 1

ğŸ”¹ Step 3: åŠ å…¥ 2 â†’ path = [1, 2]ï¼Œå‘¼å« backtrack(2, [1, 2])
- res = [[], [1], [1, 2]]

- start = 2ï¼Œi = 2

ğŸ”¹ Step 4: åŠ å…¥ 3 â†’ path = [1, 2, 3]ï¼Œå‘¼å« backtrack(3, [1, 2, 3])
- res = [[], [1], [1, 2], [1, 2, 3]]

- start = 3ï¼Œè¶…å‡ºç¯„åœï¼Œè¿”å›

- ğŸ”¹ å›æº¯ï¼šç§»é™¤ 3 â†’ å›åˆ° path = [1, 2]
    - i = 2 å®Œç•¢ â†’ è¿”å›ä¸Šä¸€å±¤

- ğŸ”¹ å›æº¯ï¼šç§»é™¤ 2 â†’ å›åˆ° path = [1]
    - ç¾åœ¨ i = 2

ğŸ”¹ Step 5: åŠ å…¥ 3 â†’ path = [1, 3]ï¼Œå‘¼å« backtrack(3, [1, 3])
- res = [[], [1], [1, 2], [1, 2, 3], [1, 3]]

- è¶…å‡ºé‚Šç•Œï¼Œè¿”å›

- ğŸ”¹ å›æº¯ï¼šç§»é™¤ 3 â†’ å›åˆ° path = [1]
    - i = 2 å®Œç•¢ â†’ è¿”å›ä¸Šä¸€å±¤

- ğŸ”¹ å›æº¯ï¼šç§»é™¤ 1 â†’ å›åˆ° path = []
    - ç¾åœ¨ i = 1

ğŸ”¹ Step 6: åŠ å…¥ 2 â†’ path = [2]ï¼Œå‘¼å« backtrack(2, [2])
- res = [[], [1], [1, 2], [1, 2, 3], [1, 3], [2]]

ğŸ”¹ Step 7: åŠ å…¥ 3 â†’ path = [2, 3]ï¼Œå‘¼å« backtrack(3, [2, 3])
- res = [..., [2, 3]] â†’ è¶…å‡ºï¼Œå›æº¯

- ğŸ”¹ å›æº¯ï¼šç§»é™¤ 3 â†’ path = [2] â†’ ç§»é™¤ 2 â†’ å›åˆ° []
    - ç¾åœ¨ i = 2

ğŸ”¹ Step 8: åŠ å…¥ 3 â†’ path = [3]ï¼Œå‘¼å« backtrack(3, [3])
- res = [..., [3]]

ğŸ”š çµæŸï¼Œæœ€çµ‚ res = [[], [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]]

#### ğŸ•’ æ™‚é–“è¤‡é›œåº¦ï¼ˆTime Complexityï¼‰
- æ¯å€‹å…ƒç´ éƒ½æœ‰é¸æˆ–ä¸é¸å…©ç¨®é¸æ“‡

- æ‰€ä»¥ç¸½å…±æœ‰ 2^ğ‘› ç¨®å­é›†

- æ¯å€‹å­é›†æœ€é•·é•·åº¦ç‚º ğ‘› ï¼Œè¤‡è£½ path çš„æˆæœ¬æ˜¯ O(n)

ç¸½æ™‚é–“è¤‡é›œåº¦ï¼šO(n Ã— 2^n)

---

### æ–¹æ³•äºŒï¼šä½å…ƒæ“ä½œæ³•ï¼ˆBit Manipulationï¼‰
```python
from typing import List

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        n = len(nums)
        for i in range(1 << n):  # 2^n
            subset = []
            for j in range(n):
                if i & (1 << j):
                    subset.append(nums[j])
            res.append(subset)
        return res
```
#### ğŸ“˜ å®Œæ•´ç¨‹å¼ç¢¼èˆ‡è©³ç´°èªªæ˜
```python
from typing import List

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        n = len(nums)
        for i in range(1 << n):  # 1 << n ç›¸ç•¶æ–¼ 2^nï¼Œæšèˆ‰æ‰€æœ‰å¯èƒ½å­é›†çš„ç·¨ç¢¼
```
- ğŸ§  ç‚ºä»€éº¼è¦ 1 << nï¼Ÿ
    - å¦‚æœæœ‰ n å€‹å…ƒç´ ï¼Œæ¯å€‹å…ƒç´ éƒ½å¯ä»¥ã€Œé¸ã€æˆ–ã€Œä¸é¸ã€ â†’ 2 å€‹é¸é …

    - æ‰€ä»¥ä¸€å…±æœ‰ 2^ğ‘› ç¨®å­é›†

    - æŠŠæ¯ç¨®é¸æ“‡ç”¨ äºŒé€²ä½ è¡¨ç¤ºï¼Œä¾‹å¦‚ i = 5 â†’ 101 è¡¨ç¤ºç¬¬ 0 å’Œç¬¬ 2 å€‹å…ƒç´ è¢«é¸ä¸­
```python
subset = []
for j in range(n):
    if i & (1 << j):
        subset.append(nums[j])
```
- ğŸ“˜ èªªæ˜ï¼ši & (1 << j)
    - 1 << jï¼šè¡¨ç¤ºç¬¬ j ä½çš„ä½å…ƒç‚º 1

    - i & (1 << j)ï¼šæª¢æŸ¥ i çš„ç¬¬ j ä½æ˜¯ä¸æ˜¯ 1ï¼Œè‹¥æ˜¯ä»£è¡¨ nums[j] è¦åŠ å…¥å­é›†

- ä¾‹å­ï¼šnums = [1,2,3]ï¼Œi = 5ï¼ˆäºŒé€²ä½ 101ï¼‰

    - j = 0 â†’ 1 << 0 = 1 â†’ 5 & 1 = 1 â†’ åŠ å…¥ nums[0] = 1

    - j = 1 â†’ 1 << 1 = 2 â†’ 5 & 2 = 0 â†’ ä¸åŠ  nums[1]

    - j = 2 â†’ 1 << 2 = 4 â†’ 5 & 4 = 4 â†’ åŠ å…¥ nums[2] = 3

    - æœ€çµ‚ subset = [1, 3]
```python
    res.append(subset)
return res
```
- æŠŠæ¯æ¬¡çµ„åˆå‡ºä¾†çš„ subset åŠ å…¥çµæœé™£åˆ— res è£¡

#### ğŸ”¢ çµæœç¯„ä¾‹
nums = [1,2,3]ï¼Œå‰‡ç¸½å…± 2^3 = 8 ç¨®ï¼š
```less
i (binary) | å­é›†
-----------|------------------
000 (0)    | []
001 (1)    | [1]
010 (2)    | [2]
011 (3)    | [1,2]
100 (4)    | [3]
101 (5)    | [1,3]
110 (6)    | [2,3]
111 (7)    | [1,2,3]
```

#### â± æ™‚é–“èˆ‡ç©ºé–“è¤‡é›œåº¦åˆ†æ
- æ™‚é–“è¤‡é›œåº¦ï¼š O(n Ã— 2^n) æ¯å€‹å­é›†æœ€å¤šé•·åº¦ç‚º nï¼Œå…± 2^n å€‹å­é›†ã€‚

- ç©ºé–“è¤‡é›œåº¦ï¼š O(n Ã— 2^n)ï¼ˆè¼¸å‡ºç©ºé–“ï¼‰

#### ğŸ“˜ å­¸åˆ°çš„é‡é»
- ä½¿ç”¨ã€Œä½å…ƒç·¨ç¢¼ã€æŠ€å·§ç”¢ç”Ÿå­é›†

- äºŒé€²ä½æšèˆ‰æ³•é©åˆç”¨æ–¼æšèˆ‰æ‰€æœ‰ã€Œé¸æˆ–ä¸é¸ã€æƒ…å¢ƒ

- 1 << n è¡¨ç¤º 2^nï¼Œi & (1 << j) æ˜¯æª¢æŸ¥ i çš„ç¬¬ j ä½

---

## ğŸ“Œ å­¸ç¿’é‡é» | What I Learned
- ç†è§£å›æº¯æ³•å¦‚ä½•åœ¨æ¯ä¸€æ­¥åšå‡ºé¸æ“‡ï¼Œä¸¦åœ¨éœ€è¦æ™‚å›é€€ï¼Œæ¢ç´¢æ‰€æœ‰å¯èƒ½çš„è§£ã€‚

- å­¸æœƒä½¿ç”¨ä½å…ƒæ“ä½œä¾†ç”Ÿæˆæ‰€æœ‰å­é›†ï¼Œé€éäºŒé€²ä½çš„æ–¹å¼è¡¨ç¤ºæ¯å€‹å…ƒç´ çš„é¸æ“‡ã€‚

- æŒæ¡å¦‚ä½•è™•ç†çµ„åˆå•é¡Œï¼Œç‰¹åˆ¥æ˜¯åœ¨å…ƒç´ ä¸é‡è¤‡çš„æƒ…æ³ä¸‹ç”Ÿæˆæ‰€æœ‰å­é›†ã€‚